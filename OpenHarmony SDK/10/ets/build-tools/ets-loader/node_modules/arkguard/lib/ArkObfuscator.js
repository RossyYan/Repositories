"use strict";
/*
 * Copyright (c) 2023 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiExtractor = exports.ArkObfuscator = exports.readProjectProperties = exports.getMapFromJson = exports.renamePropertyModule = exports.renameIdentifierModule = void 0;
const typescript_1 = require("typescript");
const fs = __importStar(require("fs"));
const path_1 = __importDefault(require("path"));
const source_map_1 = __importDefault(require("source-map"));
const FileUtils_1 = require("./utils/FileUtils");
const TransformerManager_1 = require("./transformers/TransformerManager");
const SourceMapUtil_1 = require("./utils/SourceMapUtil");
const NameCacheUtil_1 = require("./utils/NameCacheUtil");
Object.defineProperty(exports, "getMapFromJson", { enumerable: true, get: function () { return NameCacheUtil_1.getMapFromJson; } });
const ListUtil_1 = require("./utils/ListUtil");
const ApiReader_1 = require("./common/ApiReader");
Object.defineProperty(exports, "readProjectProperties", { enumerable: true, get: function () { return ApiReader_1.readProjectProperties; } });
const ApiExtractor_1 = require("./common/ApiExtractor");
Object.defineProperty(exports, "ApiExtractor", { enumerable: true, get: function () { return ApiExtractor_1.ApiExtractor; } });
const es6_reserved_properties_json_1 = __importDefault(require("./configs/preset/es6_reserved_properties.json"));
exports.renameIdentifierModule = require('./transformers/rename/RenameIdentifierTransformer');
exports.renamePropertyModule = require('./transformers/rename/RenamePropertiesTransformer');
const JSON_TEXT_INDENT_LENGTH = 2;
class ArkObfuscator {
    constructor(sourceFiles, configPath) {
        this.mSourceFiles = sourceFiles;
        this.mConfigPath = configPath;
        this.mCompilerOptions = {};
        this.mTransformers = [];
    }
    /**
     * init ArkObfuscator according to user config
     * should be called after constructor
     */
    init(config) {
        if (!this.mConfigPath && !config) {
            return false;
        }
        if (this.mConfigPath) {
            config = FileUtils_1.FileUtils.readFileAsJson(this.mConfigPath);
        }
        this.mCustomProfiles = config;
        if (this.mCustomProfiles.mCompact) {
            this.mTextWriter = typescript_1.createObfTextSingleLineWriter();
        }
        else {
            this.mTextWriter = typescript_1.createTextWriter('\n');
        }
        if (this.mCustomProfiles.mEnableSourceMap) {
            this.mCompilerOptions.sourceMap = true;
        }
        // load transformers
        this.mTransformers = TransformerManager_1.TransformerManager.getInstance().loadTransformers(this.mCustomProfiles);
        if (ApiReader_1.needReadApiInfo(this.mCustomProfiles)) {
            this.mCustomProfiles.mNameObfuscation.mReservedProperties = ListUtil_1.ListUtil.uniqueMergeList(this.mCustomProfiles.mNameObfuscation.mReservedProperties, this.mCustomProfiles.mNameObfuscation.mReservedNames, es6_reserved_properties_json_1.default);
        }
        return true;
    }
    /**
     * Obfuscate all the source files.
     */
    obfuscateFiles() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!path_1.default.isAbsolute(this.mCustomProfiles.mOutputDir)) {
                this.mCustomProfiles.mOutputDir = path_1.default.join(path_1.default.dirname(this.mConfigPath), this.mCustomProfiles.mOutputDir);
            }
            if (this.mCustomProfiles.mOutputDir && !fs.existsSync(this.mCustomProfiles.mOutputDir)) {
                fs.mkdirSync(this.mCustomProfiles.mOutputDir);
            }
            ApiReader_1.readProjectProperties(this.mSourceFiles, this.mCustomProfiles);
            this.readPropertyCache(this.mCustomProfiles.mOutputDir);
            // support directory and file obfuscate
            for (const sourcePath of this.mSourceFiles) {
                if (!fs.existsSync(sourcePath)) {
                    console.error(`File ${FileUtils_1.FileUtils.getFileName(sourcePath)} is not found.`);
                    return;
                }
                if (fs.lstatSync(sourcePath).isFile()) {
                    yield this.obfuscateFile(sourcePath, this.mCustomProfiles.mOutputDir);
                    continue;
                }
                const dirPrefix = FileUtils_1.FileUtils.getPrefix(sourcePath);
                yield this.obfuscateDir(sourcePath, dirPrefix);
            }
            this.producePropertyCache(this.mCustomProfiles.mOutputDir);
        });
    }
    /**
     * obfuscate directory
     * @private
     */
    obfuscateDir(dirName, dirPrefix) {
        return __awaiter(this, void 0, void 0, function* () {
            const currentDir = FileUtils_1.FileUtils.getPathWithoutPrefix(dirName, dirPrefix);
            const newDir = path_1.default.join(this.mCustomProfiles.mOutputDir, currentDir);
            if (!fs.existsSync(newDir)) {
                fs.mkdirSync(newDir);
            }
            const fileNames = fs.readdirSync(dirName);
            for (let fileName of fileNames) {
                const filePath = path_1.default.join(dirName, fileName);
                if (fs.lstatSync(filePath).isFile()) {
                    yield this.obfuscateFile(filePath, newDir);
                    continue;
                }
                if (fileName === 'node_modules' || fileName === 'oh_modules') {
                    continue;
                }
                yield this.obfuscateDir(filePath, dirPrefix);
            }
        });
    }
    readNameCache(sourceFile, outputDir) {
        if (!this.mCustomProfiles.mNameObfuscation.mEnable || !this.mCustomProfiles.mEnableNameCache) {
            return;
        }
        const nameCachePath = path_1.default.join(outputDir, FileUtils_1.FileUtils.getFileName(sourceFile) + NameCacheUtil_1.NAME_CACHE_SUFFIX);
        const nameCache = NameCacheUtil_1.readCache(nameCachePath);
        exports.renameIdentifierModule.historyNameCache = NameCacheUtil_1.getMapFromJson(nameCache);
    }
    readPropertyCache(outputDir) {
        if (!this.mCustomProfiles.mNameObfuscation.mRenameProperties || !this.mCustomProfiles.mEnableNameCache) {
            return;
        }
        const propertyCachePath = path_1.default.join(outputDir, NameCacheUtil_1.PROPERTY_CACHE_FILE);
        const propertyCache = NameCacheUtil_1.readCache(propertyCachePath);
        if (!propertyCache) {
            return;
        }
        exports.renamePropertyModule.historyMangledTable = NameCacheUtil_1.getMapFromJson(propertyCache);
    }
    produceNameCache(namecache, sourceFile, outputDir) {
        const nameCachePath = path_1.default.join(outputDir, FileUtils_1.FileUtils.getFileName(sourceFile) + NameCacheUtil_1.NAME_CACHE_SUFFIX);
        fs.writeFileSync(nameCachePath, JSON.stringify(namecache, null, JSON_TEXT_INDENT_LENGTH));
    }
    producePropertyCache(outputDir) {
        if (this.mCustomProfiles.mNameObfuscation.mRenameProperties && this.mCustomProfiles.mEnableNameCache) {
            const propertyCachePath = path_1.default.join(outputDir, NameCacheUtil_1.PROPERTY_CACHE_FILE);
            NameCacheUtil_1.writeCache(exports.renamePropertyModule.globalMangledTable, propertyCachePath);
        }
    }
    mergeSourceMap(originMap, newMap) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!originMap) {
                return newMap;
            }
            if (!newMap) {
                return originMap;
            }
            const originConsumer = yield new source_map_1.default.SourceMapConsumer(originMap);
            const newConsumer = yield new source_map_1.default.SourceMapConsumer(newMap);
            const newMappingList = [];
            newConsumer.eachMapping((mapping) => {
                if (mapping.originalLine == null) {
                    return;
                }
                const originalPos = originConsumer.originalPositionFor({
                    line: mapping.originalLine,
                    column: mapping.originalColumn
                });
                if (originalPos.source == null) {
                    return;
                }
                mapping.originalLine = originalPos.line;
                mapping.originalColumn = originalPos.column;
                newMappingList.push(mapping);
            });
            const updatedGenerator = source_map_1.default.SourceMapGenerator.fromSourceMap(newConsumer);
            updatedGenerator['_file'] = originMap.file;
            updatedGenerator['_mappings']['_array'] = newMappingList;
            return JSON.parse(updatedGenerator.toString());
        });
    }
    /**
     * A Printer to output obfuscated codes.
     */
    createObfsPrinter() {
        // set print options
        let printerOptions = {};
        if (this.mCustomProfiles.mRemoveComments) {
            printerOptions.removeComments = true;
        }
        return typescript_1.createPrinter(printerOptions);
    }
    isObfsIgnoreFile(fileName) {
        let suffix = FileUtils_1.FileUtils.getFileExtension(fileName);
        return (suffix !== 'js' && suffix !== 'ts') || fileName.endsWith('.d.ts');
    }
    /**
     * Obfuscate single source file with path provided
     *
     * @param sourceFilePath single source file path
     * @param outputDir
     */
    obfuscateFile(sourceFilePath, outputDir) {
        return __awaiter(this, void 0, void 0, function* () {
            const fileName = FileUtils_1.FileUtils.getFileName(sourceFilePath);
            if (this.isObfsIgnoreFile(fileName)) {
                fs.copyFileSync(sourceFilePath, path_1.default.join(outputDir, fileName));
                return;
            }
            let content = FileUtils_1.FileUtils.readFile(sourceFilePath);
            this.readNameCache(sourceFilePath, outputDir);
            const mixedInfo = yield this.obfuscate(content, sourceFilePath);
            if (outputDir && mixedInfo) {
                fs.writeFileSync(path_1.default.join(outputDir, FileUtils_1.FileUtils.getFileName(sourceFilePath)), mixedInfo.content);
                if (this.mCustomProfiles.mEnableSourceMap && mixedInfo.sourceMap) {
                    fs.writeFileSync(path_1.default.join(outputDir, FileUtils_1.FileUtils.getFileName(sourceFilePath) + '.map'), JSON.stringify(mixedInfo.sourceMap, null, JSON_TEXT_INDENT_LENGTH));
                }
                if (this.mCustomProfiles.mEnableNameCache && this.mCustomProfiles.mEnableNameCache) {
                    this.produceNameCache(mixedInfo.nameCache, sourceFilePath, outputDir);
                }
            }
        });
    }
    /**
     * Obfuscate ast of a file.
     * @param content ast or source code of a source file
     * @param sourceFilePath
     * @param previousStageSourceMap
     * @param historyNameCache
     */
    obfuscate(content, sourceFilePath, previousStageSourceMap, historyNameCache) {
        return __awaiter(this, void 0, void 0, function* () {
            let ast;
            let result = { content: undefined };
            if (this.isObfsIgnoreFile(sourceFilePath)) {
                // need add return value
                return result;
            }
            if (typeof content === 'string') {
                ast = typescript_1.createSourceFile(sourceFilePath, content, typescript_1.ScriptTarget.ES2015, true);
            }
            else {
                ast = content;
            }
            if (ast.statements.length === 0) {
                return result;
            }
            if (historyNameCache && this.mCustomProfiles.mNameObfuscation) {
                exports.renameIdentifierModule.historyNameCache = historyNameCache;
            }
            let transformedResult = typescript_1.transform(ast, this.mTransformers, this.mCompilerOptions);
            ast = transformedResult.transformed[0];
            // convert ast to output source file and generate sourcemap if needed.
            let sourceMapGenerator = undefined;
            if (this.mCustomProfiles.mEnableSourceMap) {
                sourceMapGenerator = SourceMapUtil_1.getSourceMapGenerator(sourceFilePath);
            }
            this.createObfsPrinter().writeFile(ast, this.mTextWriter, sourceMapGenerator);
            result.content = this.mTextWriter.getText();
            if (this.mCustomProfiles.mEnableSourceMap && sourceMapGenerator) {
                let sourceMapJson = sourceMapGenerator.toJSON();
                sourceMapJson.sourceRoot = '';
                sourceMapJson.file = path_1.default.basename(sourceFilePath);
                if (previousStageSourceMap) {
                    sourceMapJson = yield this.mergeSourceMap(previousStageSourceMap, sourceMapJson);
                }
                result.sourceMap = sourceMapJson;
            }
            if (this.mCustomProfiles.mEnableNameCache) {
                result.nameCache = Object.fromEntries(exports.renameIdentifierModule.nameCache);
            }
            // clear cache of text writer
            this.mTextWriter.clear();
            if (exports.renameIdentifierModule.nameCache) {
                exports.renameIdentifierModule.nameCache.clear();
            }
            return result;
        });
    }
}
exports.ArkObfuscator = ArkObfuscator;
//# sourceMappingURL=ArkObfuscator.js.map