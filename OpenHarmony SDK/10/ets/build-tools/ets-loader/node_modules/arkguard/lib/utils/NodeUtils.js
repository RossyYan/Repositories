"use strict";
/*
 * Copyright (c) 2023 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeUtils = void 0;
const typescript_1 = require("typescript");
class NodeUtils {
    static isPropertyDeclarationNode(node) {
        let parent = node.parent;
        if (!parent) {
            return false;
        }
        /** eg: { 'name'' : 'akira' }, pass */
        if (typescript_1.isPropertyAssignment(parent)) {
            return parent.name === node;
        }
        if (typescript_1.isComputedPropertyName(parent) && parent.expression === node) {
            return true;
        }
        /** object binding pattern */
        if (typescript_1.isBindingElement(parent) && parent.propertyName === node) {
            return true;
        }
        /** eg: interface/type inf { 'name' : string}, pass */
        if (typescript_1.isPropertySignature(parent) && parent.name === node) {
            return true;
        }
        /** eg: interface/type T1 { func(arg: string): number;} */
        if (typescript_1.isMethodSignature(parent) && parent.name === node) {
            return true;
        }
        /** eg: enum { xxx = 1}; */
        if (typescript_1.isEnumMember(parent) && parent.name === node) {
            return true;
        }
        /** class { private name= 1}; */
        if (typescript_1.isPropertyDeclaration(parent) && parent.name === node) {
            return true;
        }
        /** class {'getName': function() {}} let _ = { getName() [}} */
        if (typescript_1.isMethodDeclaration(parent) && parent.name === node) {
            return true;
        }
        if (typescript_1.isSetAccessor(parent) && parent.name === node) {
            return true;
        }
        return typescript_1.isGetAccessor(parent) && parent.name === node;
    }
    static isPropertyOrElementAccessNode(node) {
        return this.isPropertyAccessNode(node) || this.isElementAccessNode(node) || false;
    }
    static isPropertyAccessNode(node) {
        let parent = node.parent;
        if (!parent) {
            return false;
        }
        /** eg: a.b = 1 */
        if (typescript_1.isPropertyAccessExpression(parent) && parent.name === node) {
            return true;
        }
        return typescript_1.isQualifiedName(parent) && parent.right === node;
    }
    static isElementAccessNode(node) {
        let parent = node.parent;
        if (!parent) {
            return false;
        }
        return typescript_1.isElementAccessExpression(parent) && parent.argumentExpression === node;
    }
    static isClassPropertyInConstructorParams(node) {
        if (!typescript_1.isIdentifier(node)) {
            return false;
        }
        if (!node.parent || !typescript_1.isParameter(node.parent)) {
            return false;
        }
        return node.parent.parent && typescript_1.isConstructorDeclaration(node.parent.parent);
    }
    static isClassPropertyInConstructorBody(node, constructorParams) {
        if (!typescript_1.isIdentifier(node)) {
            return false;
        }
        const id = node.escapedText.toString();
        let curNode = node.parent;
        while (curNode) {
            if (typescript_1.isConstructorDeclaration(curNode) && constructorParams.has(id)) {
                return true;
            }
            curNode = curNode.parent;
        }
        return false;
    }
    static isPropertyNode(node) {
        if (this.isPropertyOrElementAccessNode(node)) {
            return true;
        }
        return this.isPropertyDeclarationNode(node);
    }
    static isObjectBindingPatternAssignment(node) {
        if (!node || !node.parent || !typescript_1.isVariableDeclaration(node.parent)) {
            return false;
        }
        const initializer = node.parent.initializer;
        return initializer && typescript_1.isCallExpression(initializer);
    }
}
exports.NodeUtils = NodeUtils;
//# sourceMappingURL=NodeUtils.js.map