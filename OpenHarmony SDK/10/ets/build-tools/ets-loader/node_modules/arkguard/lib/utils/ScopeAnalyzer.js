"use strict";
/*
 * Copyright (c) 2023 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const typescript_1 = require("typescript");
const NodeUtils_1 = require("./NodeUtils");
const OhsUtil_1 = require("./OhsUtil");
/**
 * kind of a scope
 */
var secharmony;
(function (secharmony) {
    /**
     * type of scope
     */
    let ScopeKind;
    (function (ScopeKind) {
        ScopeKind[ScopeKind["GLOBAL"] = 0] = "GLOBAL";
        ScopeKind[ScopeKind["MODULE"] = 1] = "MODULE";
        ScopeKind[ScopeKind["FUNCTION"] = 2] = "FUNCTION";
        ScopeKind[ScopeKind["CLASS"] = 3] = "CLASS";
        ScopeKind[ScopeKind["FOR"] = 4] = "FOR";
        ScopeKind[ScopeKind["SWITCH"] = 5] = "SWITCH";
        ScopeKind[ScopeKind["BLOCK"] = 6] = "BLOCK";
        ScopeKind[ScopeKind["INTERFACE"] = 7] = "INTERFACE";
        ScopeKind[ScopeKind["CATCH"] = 8] = "CATCH";
        ScopeKind[ScopeKind["ENUM"] = 9] = "ENUM";
        ScopeKind[ScopeKind["OBJECT_LITERAL"] = 10] = "OBJECT_LITERAL";
    })(ScopeKind = secharmony.ScopeKind || (secharmony.ScopeKind = {}));
    function isGlobalScope(scope) {
        return scope.kind === ScopeKind.GLOBAL;
    }
    secharmony.isGlobalScope = isGlobalScope;
    function isFunctionScope(scope) {
        return scope.kind === ScopeKind.FUNCTION;
    }
    secharmony.isFunctionScope = isFunctionScope;
    function isClassScope(scope) {
        return scope.kind === ScopeKind.CLASS;
    }
    secharmony.isClassScope = isClassScope;
    function isInterfaceScope(scope) {
        return scope.kind === ScopeKind.INTERFACE;
    }
    secharmony.isInterfaceScope = isInterfaceScope;
    function isEnumScope(scope) {
        return scope.kind === ScopeKind.ENUM;
    }
    secharmony.isEnumScope = isEnumScope;
    function isObjectLiteralScope(scope) {
        return scope.kind === ScopeKind.OBJECT_LITERAL;
    }
    secharmony.isObjectLiteralScope = isObjectLiteralScope;
    function createScope(name, node, type, lexicalScope = false, upper) {
        var _a;
        // scope name
        let scopeName = name;
        // kind of a scope, such as global ,function like, block ..
        let kind = type;
        // node of a current scope in ast.
        let block = node;
        // parent scope of current scope
        let parent = upper;
        // sub scopes of current scope
        let children = [];
        //  symbols define in current scope
        let defs = new Set();
        // labels in current scope
        let labels = [];
        let importNames = new Set();
        let exportNames = new Set();
        let mangledNames = new Set();
        // location path
        let loc = (parent === null || parent === void 0 ? void 0 : parent.loc) ? parent.loc + '#' + scopeName : scopeName;
        // current scope
        let current = {
            'name': scopeName,
            'kind': kind,
            'block': block,
            'parent': parent,
            'children': children,
            'defs': defs,
            'labels': labels,
            'loc': loc,
            'importNames': importNames,
            'exportNames': exportNames,
            'mangledNames': mangledNames,
            addChild,
            addDefinition,
            addLabel,
            getSymbolLocation,
            getLabelLocation,
        };
        (_a = current.parent) === null || _a === void 0 ? void 0 : _a.addChild(current);
        return current;
        function addChild(child) {
            current.children.push(child);
        }
        function addDefinition(def) {
            current.defs.add(def);
        }
        function addLabel(label) {
            current.labels.push(label);
        }
        function getSymbolLocation(sym) {
            if (!defs.has(sym)) {
                return '';
            }
            return current.loc ? sym.name : current.loc + '#' + sym.name;
        }
        function getLabelLocation(label) {
            if (!current.labels.includes(label)) {
                return '';
            }
            let index = current.labels.findIndex((lb) => {
                return lb === label;
            });
            return current.loc ? label.name : current.loc + '#' + index + label.name;
        }
    }
    secharmony.createScope = createScope;
    function createLabel(node, scope, parent) {
        let labelName = '$' + scope.labels.length + '_' + node.label.text;
        let label = {
            'name': node.label.text,
            'locInfo': labelName,
            'refs': [node.label],
            'parent': parent,
            'children': [],
            'scope': scope,
        };
        scope.labels.push(label);
        parent === null || parent === void 0 ? void 0 : parent.children.push(label);
        return label;
    }
    secharmony.createLabel = createLabel;
    function createScopeManager() {
        let reservedNames = new Set();
        let root;
        let current;
        let scopes = [];
        let checker = null;
        let upperLabel = undefined;
        return {
            getReservedNames,
            analyze,
            getRootScope,
            getScopeOfNode,
        };
        function analyze(ast, typeChecker) {
            checker = typeChecker;
            analyzeScope(ast);
        }
        function getReservedNames() {
            return reservedNames;
        }
        function getRootScope() {
            return root;
        }
        function addSymbolInScope(node) {
            let defSymbols = node === null || node === void 0 ? void 0 : node.locals;
            if (!defSymbols) {
                return;
            }
            defSymbols.forEach((def) => {
                // with export identification, special handling.
                if (def.exportSymbol) {
                    current.exportNames.add(def.name);
                }
                current.addDefinition(def);
            });
        }
        /**
         * analyze chain of scopes
         *
         * @param node
         */
        function analyzeScope(node) {
            switch (node.kind) {
                // global
                case typescript_1.SyntaxKind.SourceFile:
                    analyzeSourceFile(node);
                    break;
                // namespace or module
                case typescript_1.SyntaxKind.ModuleDeclaration:
                    analyzeModule(node);
                    break;
                // function like
                case typescript_1.SyntaxKind.FunctionDeclaration:
                case typescript_1.SyntaxKind.MethodDeclaration:
                case typescript_1.SyntaxKind.GetAccessor:
                case typescript_1.SyntaxKind.SetAccessor:
                case typescript_1.SyntaxKind.Constructor:
                case typescript_1.SyntaxKind.FunctionExpression:
                case typescript_1.SyntaxKind.ArrowFunction:
                    analyzeFunctionLike(node);
                    break;
                // class like
                case typescript_1.SyntaxKind.ClassExpression:
                case typescript_1.SyntaxKind.ClassDeclaration:
                    analyzeClassLike(node);
                    break;
                // for like
                case typescript_1.SyntaxKind.ForStatement:
                case typescript_1.SyntaxKind.ForInStatement:
                case typescript_1.SyntaxKind.ForOfStatement:
                    analyzeForLike(node);
                    break;
                case typescript_1.SyntaxKind.CaseBlock:
                    // caseBlock property in switch statement
                    analyzeSwitch(node);
                    break;
                case typescript_1.SyntaxKind.Block:
                    // while, do ...while, block, if/else..
                    analyzeBlock(node);
                    break;
                case typescript_1.SyntaxKind.InterfaceDeclaration:
                    analyzeInterface(node);
                    break;
                case typescript_1.SyntaxKind.EnumDeclaration:
                    analyzeEnum(node);
                    break;
                case typescript_1.SyntaxKind.Identifier:
                    analyzeSymbol(node);
                    break;
                case typescript_1.SyntaxKind.TypeAliasDeclaration:
                    analyzeTypeAliasDeclaration(node);
                    break;
                case typescript_1.SyntaxKind.LabeledStatement:
                    analyzeLabel(node);
                    break;
                case typescript_1.SyntaxKind.BreakStatement:
                case typescript_1.SyntaxKind.ContinueStatement:
                    analyzeBreakOrContinue(node);
                    break;
                case typescript_1.SyntaxKind.ImportSpecifier:
                    analyzeImportNames(node);
                    break;
                case typescript_1.SyntaxKind.ObjectBindingPattern:
                    analyzeObjectBindingPatternRequire(node);
                    break;
                case typescript_1.SyntaxKind.ObjectLiteralExpression:
                    analyzeObjectLiteralExpression(node);
                    break;
                case typescript_1.SyntaxKind.ExportSpecifier:
                    analyzeExportNames(node);
                    break;
                case typescript_1.SyntaxKind.CatchClause:
                    analyzeCatchClause(node);
                    break;
                default:
                    typescript_1.forEachChild(node, analyzeScope);
                    break;
            }
        }
        function analyzeImportNames(node) {
            try {
                if (node.propertyName) {
                    current.importNames.add(node.propertyName.text);
                }
                else {
                    current.importNames.add(node.name.text);
                }
                typescript_1.forEachChild(node, analyzeScope);
            }
            catch (e) {
                console.error(e);
            }
        }
        function analyzeObjectBindingPatternRequire(node) {
            if (!NodeUtils_1.NodeUtils.isObjectBindingPatternAssignment(node)) {
                typescript_1.forEachChild(node, analyzeScope);
                return;
            }
            if (!node.elements) {
                return;
            }
            node.elements.forEach((bindingElement) => {
                if (!bindingElement) {
                    return;
                }
                if (!bindingElement.name || !typescript_1.isIdentifier(bindingElement.name)) {
                    return;
                }
                if (bindingElement.propertyName) {
                    return;
                }
                current.importNames.add(bindingElement.name.text);
            });
        }
        function analyzeObjectLiteralExpression(node) {
            let scopeName = '$' + current.children.length;
            current = createScope(scopeName, node, ScopeKind.OBJECT_LITERAL, false, current);
            scopes.push(current);
            addSymbolInScope(node);
            typescript_1.forEachChild(node, analyzeScope);
            current = current.parent || current;
        }
        function analyzeExportNames(node) {
            // get export names.
            current.exportNames.add(node.name.text);
            typescript_1.forEachChild(node, analyzeScope);
        }
        function analyzeBreakOrContinue(node) {
            var _a, _b;
            let labelName = (_b = (_a = node === null || node === void 0 ? void 0 : node.label) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : '';
            let label = findTargetLabel(labelName);
            if (!label) {
                return;
            }
            if (node.label) {
                label === null || label === void 0 ? void 0 : label.refs.push(node.label);
            }
            typescript_1.forEachChild(node, analyzeScope);
        }
        function findTargetLabel(labelName) {
            if (!labelName) {
                return null;
            }
            let label = upperLabel;
            // avoid loop
            while (label && (label === null || label === void 0 ? void 0 : label.name) !== labelName) {
                label = label === null || label === void 0 ? void 0 : label.parent;
            }
            return label;
        }
        function analyzeSourceFile(node) {
            let scopeName = '';
            root = createScope(scopeName, node, ScopeKind.GLOBAL, true);
            current = root;
            scopes.push(current);
            // locals of a node(scope) is symbol that defines in current scope(node).
            addSymbolInScope(node);
            typescript_1.forEachChild(node, analyzeScope);
            current = current.parent || current;
            extractImportExports();
        }
        function analyzeCatchClause(node) {
            let scopeName = '$' + current.children.length;
            current = createScope(scopeName, node, ScopeKind.CATCH, false, current);
            scopes.push(current);
            // add in catch declaration.
            addSymbolInScope(node);
            if (node.block) {
                // add in block declaration.
                addSymbolInScope(node.block);
            }
            typescript_1.forEachChild(node.block, analyzeScope);
            current = current.parent || current;
        }
        function extractImportExports() {
            for (const def of current.defs) {
                if (def.exportSymbol) {
                    if (!current.exportNames.has(def.name)) {
                        current.exportNames.add(def.name);
                    }
                    const name = def.exportSymbol.name;
                    if (!current.exportNames.has(name)) {
                        current.exportNames.add(name);
                    }
                }
            }
        }
        function analyzeTypeAliasDeclaration(node) {
            var _a;
            let scopeName = (_a = node.name.text) !== null && _a !== void 0 ? _a : '$' + current.children.length;
            current = createScope(scopeName, node, ScopeKind.INTERFACE, true, current);
            scopes.push(current);
            addSymbolInScope(node);
            typescript_1.forEachChild(node, analyzeScope);
            current = current.parent || current;
        }
        /**
         * namespace ns {
         *     ...
         * }
         * @param node
         */
        function analyzeModule(node) {
            var _a;
            /**
             * if it is an anonymous scope, generate the scope name with a number,
             * which is based on the order of its child scopes in the upper scope
             */
            let scopeName = (_a = node.name.text) !== null && _a !== void 0 ? _a : '$' + current.children.length;
            current = createScope(scopeName, node, ScopeKind.MODULE, true, current);
            scopes.push(current);
            addSymbolInScope(node);
            typescript_1.forEachChild(node, analyzeScope);
            current = current.parent || current;
        }
        /**
         * exclude constructor's parameter witch should be treated as property, example:
         *  constructor(public name){}, name should be treated as property
         * @param node
         */
        function excludeConstructorParameter(node) {
            if (!typescript_1.isConstructorDeclaration(node)) {
                return;
            }
            const visitParam = (param) => {
                if (typescript_1.isIdentifier(param)) {
                    current.defs.forEach((def) => {
                        if (def.name === param.text) {
                            current.defs.delete(def);
                            current.mangledNames.add(def.name);
                        }
                    });
                }
                typescript_1.forEachChild(param, visitParam);
            };
            node.parameters.forEach((param) => {
                visitParam(param);
            });
        }
        /**
         * function func(param1...) {
         *     ...
         * }
         * @param node
         */
        function analyzeFunctionLike(node) {
            var _a, _b;
            let scopeName = (_b = (_a = node === null || node === void 0 ? void 0 : node.name) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : '$' + current.children.length;
            let loc = (current === null || current === void 0 ? void 0 : current.loc) ? current.loc + '#' + scopeName : scopeName;
            let overloading = false;
            for (const sub of current.children) {
                if (sub.loc === loc) {
                    overloading = true;
                    current = sub;
                    break;
                }
            }
            if (!overloading) {
                current = createScope(scopeName, node, ScopeKind.FUNCTION, true, current);
                scopes.push(current);
            }
            addSymbolInScope(node);
            if (node.symbol && current.parent && !current.parent.defs.has(node.symbol)) {
                current.parent.defs.add(node.symbol);
            }
            if (typescript_1.isFunctionDeclaration(node) || typescript_1.isMethodDeclaration(node)) {
                // function declaration requires skipping function names
                node.forEachChild((sub) => {
                    if (typescript_1.isIdentifier(sub)) {
                        return;
                    }
                    analyzeScope(sub);
                });
            }
            else {
                typescript_1.forEachChild(node, analyzeScope);
            }
            excludeConstructorParameter(node);
            current = current.parent || current;
        }
        function analyzeSwitch(node) {
            let scopeName = '$' + current.children.length;
            current = createScope(scopeName, node, ScopeKind.SWITCH, false, current);
            scopes.push(current);
            addSymbolInScope(node);
            typescript_1.forEachChild(node, analyzeScope);
            current = current.parent || current;
        }
        /**
         * ES6+ class like scope, The members of a class aren't not allow to rename in rename identifiers transformer, but
         * rename in rename properties transformer.
         *
         * @param node
         */
        function analyzeClassLike(node) {
            var _a, _b, _c, _d;
            if (typescript_1.isClassDeclaration(node) && OhsUtil_1.isViewPUBasedClass(node)) {
                reservedNames.add(node.name.text);
            }
            try {
                let scopeName = (_b = (_a = node === null || node === void 0 ? void 0 : node.name) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : '$' + current.children.length;
                current = createScope(scopeName, node, ScopeKind.CLASS, true, current);
                scopes.push(current);
                addSymbolInScope(node);
                // Class members are seen as attribute names, and  the reference of external symbols can be renamed as the same
                (_c = node.members) === null || _c === void 0 ? void 0 : _c.forEach((elm) => {
                    if (elm === null || elm === void 0 ? void 0 : elm.symbol) {
                        current.addDefinition(elm.symbol);
                    }
                });
                (_d = node.members) === null || _d === void 0 ? void 0 : _d.forEach((sub) => {
                    analyzeScope(sub);
                });
            }
            catch (e) {
                console.error(e);
            }
            current = current.parent || current;
        }
        function analyzeForLike(node) {
            let scopeName = '$' + current.children.length;
            current = createScope(scopeName, node, ScopeKind.FOR, false, current);
            scopes.push(current);
            addSymbolInScope(node);
            typescript_1.forEachChild(node, analyzeScope);
            current = current.parent || current;
        }
        function analyzeBlock(node) {
            // when block is body of a function
            if (isFunctionScope(current) && typescript_1.isFunctionLike(node.parent)) {
                // skip direct block scope in function scope
                typescript_1.forEachChild(node, analyzeScope);
                return;
            }
            let scopeName = '$' + current.children.length;
            current = createScope(scopeName, node, ScopeKind.BLOCK, false, current);
            scopes.push(current);
            addSymbolInScope(node);
            typescript_1.forEachChild(node, analyzeScope);
            current = current.parent || current;
        }
        function analyzeInterface(node) {
            var _a;
            let scopeName = node.name.text;
            current = createScope(scopeName, node, ScopeKind.INTERFACE, true, current);
            scopes.push(current);
            try {
                addSymbolInScope(node);
            }
            catch (e) {
                console.error('');
            }
            (_a = node.members) === null || _a === void 0 ? void 0 : _a.forEach((elm) => {
                if (elm === null || elm === void 0 ? void 0 : elm.symbol) {
                    current.addDefinition(elm.symbol);
                }
            });
            typescript_1.forEachChild(node, analyzeScope);
            current = current.parent || current;
        }
        function analyzeEnum(node) {
            let scopeName = node.name.text;
            current = createScope(scopeName, node, ScopeKind.ENUM, true, current);
            scopes.push(current);
            for (const member of node.members) {
                if (member.symbol) {
                    current.addDefinition(member.symbol);
                }
            }
            for (const subNode of node.members) {
                typescript_1.forEachChild(subNode, analyzeScope);
            }
            current = current.parent || current;
        }
        function analyzeSymbol(node) {
            // ignore all identifiers that treat as property in property declaration
            if (NodeUtils_1.NodeUtils.isPropertyDeclarationNode(node)) {
                return;
            }
            // ignore all identifiers that treat as property in property access
            if (NodeUtils_1.NodeUtils.isPropertyAccessNode(node)) {
                return;
            }
            let symbol = null;
            try {
                symbol = checker.getSymbolAtLocation(node);
            }
            catch (e) {
                console.error(e);
                return;
            }
            if (!symbol) {
                return;
            }
            // add def symbol that don't found in current defs.
            addSymbolIntoDefsIfNeeded(node, symbol, current.defs);
        }
        function addSymbolIntoDefsIfNeeded(node, symbol, currentDefs) {
            // process a new def not in currentDefs
            let isSameName = false;
            for (const def of currentDefs) {
                if (def.name === node.text) {
                    isSameName = true;
                    break;
                }
            }
            if (isSameName) {
                // exclude the possibility of external symbols, as those with duplicate names have been added to currentDefs (this avoids the possibility of omissions)
                if (!currentDefs.has(symbol)) {
                    currentDefs.add(symbol);
                }
                if (symbol.exportSymbol && !currentDefs.has(symbol.exportSymbol)) {
                    currentDefs.add(symbol);
                }
            }
            return isSameName;
        }
        function analyzeLabel(node) {
            // labels within the same scope are allowed to be duplicated, so label names need to have numbering information to distinguish them
            upperLabel = upperLabel ? createLabel(node, current, upperLabel) : createLabel(node, current);
            typescript_1.forEachChild(node, analyzeScope);
            upperLabel = upperLabel === null || upperLabel === void 0 ? void 0 : upperLabel.parent;
        }
        function getScopeOfNode(node) {
            if (!typescript_1.isIdentifier(node)) {
                return undefined;
            }
            let sym = checker.getSymbolAtLocation(node);
            if (!sym) {
                return undefined;
            }
            for (const scope of scopes) {
                if (scope === null || scope === void 0 ? void 0 : scope.defs.has(sym)) {
                    return scope;
                }
            }
            return undefined;
        }
    }
    secharmony.createScopeManager = createScopeManager;
})(secharmony || (secharmony = {}));
module.exports = secharmony;
//# sourceMappingURL=ScopeAnalyzer.js.map