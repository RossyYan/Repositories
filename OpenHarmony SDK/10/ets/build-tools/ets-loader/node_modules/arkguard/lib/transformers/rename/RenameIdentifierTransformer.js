"use strict";
/*
 * Copyright (c) 2023 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const typescript_1 = require("typescript");
const ScopeAnalyzer_1 = require("../../utils/ScopeAnalyzer");
const NameFactory_1 = require("../../generator/NameFactory");
const TypeUtils_1 = require("../../utils/TypeUtils");
const TransformUtil_1 = require("../../utils/TransformUtil");
const NodeUtils_1 = require("../../utils/NodeUtils");
var secharmony;
(function (secharmony) {
    /**
     * Rename Identifiers, including:
     * 1. variable name
     * 2. function name
     * 3. label name
     * 4. class name/interface name/ label name
     * we need implement some features:
     * 1. rename identifiers
     * 2. store/restore name to/from nameCache file.
     * 3. do scope analysis for identifier obfuscations
     *
     * @param option
     */
    const createRenameIdentifierFactory = function (option) {
        const profile = option === null || option === void 0 ? void 0 : option.mNameObfuscation;
        if (!profile || !profile.mEnable) {
            return null;
        }
        const openTopLevel = option === null || option === void 0 ? void 0 : option.mTopLevel;
        return renameIdentifierFactory;
        function renameIdentifierFactory(context) {
            var _a;
            let reservedNames = [...((_a = profile === null || profile === void 0 ? void 0 : profile.mReservedNames) !== null && _a !== void 0 ? _a : []), 'this', '__global'];
            let mangledSymbolNames = new Map();
            let mangledLabelNames = new Map();
            let options = {};
            if (profile.mNameGeneratorType === NameFactory_1.NameGeneratorType.HEX) {
                options.hexWithPrefixSuffix = true;
            }
            let generator = NameFactory_1.getNameGenerator(profile.mNameGeneratorType, options);
            let historyMangledNames = undefined;
            if (secharmony.historyNameCache && secharmony.historyNameCache.size > 0) {
                historyMangledNames = new Set(Array.from(secharmony.historyNameCache.values()));
            }
            let checker = undefined;
            let manager = ScopeAnalyzer_1.createScopeManager();
            let shadowIdentifiers = undefined;
            let identifierIndex = 0;
            return renameTransformer;
            /**
             * Transformer to rename identifiers
             *
             * @param node ast node of a file.
             */
            function renameTransformer(node) {
                if (!typescript_1.isSourceFile(node)) {
                    return node;
                }
                const shadowSourceAst = TypeUtils_1.TypeUtils.createNewSourceFile(node);
                checker = TypeUtils_1.TypeUtils.createChecker(shadowSourceAst);
                manager.analyze(shadowSourceAst, checker);
                manager.getReservedNames().forEach((name) => {
                    reservedNames.push(name);
                });
                // collect all identifiers of shadow sourceFile
                shadowIdentifiers = TransformUtil_1.collectIdentifiers(shadowSourceAst, context);
                if (secharmony.nameCache === undefined) {
                    secharmony.nameCache = new Map();
                }
                let root = manager.getRootScope();
                renameInScope(root);
                return typescript_1.setParentRecursive(visit(node), true);
            }
            /**
             * rename symbol table store in scopes...
             *
             * @param scope scope, such as global, module, function, block
             */
            function renameInScope(scope) {
                // process labels in scope, the label can't rename as the name of top labels.
                renameLabelsInScope(scope);
                // process symbols in scope, exclude property name.
                renameNamesInScope(scope);
                for (const subScope of scope.children) {
                    renameInScope(subScope);
                }
            }
            function renameNamesInScope(scope) {
                if (scope.parent) {
                    scope.parent.mangledNames.forEach((value) => {
                        scope.mangledNames.add(value);
                    });
                    scope.parent.importNames.forEach((value) => {
                        scope.importNames.add(value);
                    });
                }
                if (isExcludeScope(scope)) {
                    return;
                }
                scope.defs.forEach((def) => {
                    if (scope.importNames.has(def.name)) {
                        scope.defs.delete(def);
                    }
                });
                generator.reset();
                renames(scope, scope.defs, generator);
            }
            function renames(scope, defs, generator) {
                const localCache = new Map();
                findNoSymbolIdentifiers(scope);
                defs.forEach((def) => {
                    const original = def.name;
                    let mangled = original;
                    // No allow to rename reserved names.
                    if (reservedNames.includes(original) || scope.exportNames.has(def.name) || isSkippedGlobal(openTopLevel, scope)) {
                        scope.mangledNames.add(mangled);
                        mangledSymbolNames.set(def, mangled);
                        return;
                    }
                    if (mangledSymbolNames.has(def)) {
                        return;
                    }
                    const path = scope.loc + '#' + original;
                    const historyName = secharmony.historyNameCache === null || secharmony.historyNameCache === void 0 ? void 0 : secharmony.historyNameCache.get(path);
                    const specifyName = historyName ? historyName : secharmony.nameCache.get(path);
                    if (specifyName) {
                        mangled = specifyName;
                    }
                    else {
                        const sameMangled = localCache.get(original);
                        mangled = sameMangled ? sameMangled : getMangled(scope, generator);
                    }
                    // add new names to name cache
                    secharmony.nameCache.set(path, mangled);
                    scope.mangledNames.add(mangled);
                    mangledSymbolNames.set(def, mangled);
                    localCache.set(original, mangled);
                });
            }
            function isExcludeScope(scope) {
                if (ScopeAnalyzer_1.isClassScope(scope)) {
                    return true;
                }
                if (ScopeAnalyzer_1.isInterfaceScope(scope)) {
                    return true;
                }
                if (ScopeAnalyzer_1.isEnumScope(scope)) {
                    return true;
                }
                return ScopeAnalyzer_1.isObjectLiteralScope(scope);
            }
            function getMangled(scope, localGenerator) {
                let mangled = '';
                do {
                    mangled = localGenerator.getName();
                    // if it is a globally reserved name, it needs to be regenerated
                    if (reservedNames.includes(mangled)) {
                        mangled = '';
                        continue;
                    }
                    if (scope.importNames && scope.importNames.has(mangled)) {
                        mangled = '';
                        continue;
                    }
                    if (scope.exportNames && scope.exportNames.has(mangled)) {
                        mangled = '';
                        continue;
                    }
                    if (historyMangledNames && historyMangledNames.has(mangled)) {
                        mangled = '';
                        continue;
                    }
                    // the anme has already been generated in the current scope
                    if (scope.mangledNames.has(mangled)) {
                        mangled = '';
                    }
                } while (mangled === '');
                return mangled;
            }
            function renameLabelsInScope(scope) {
                const labels = scope.labels;
                if (labels.length > 0) {
                    let upperMangledLabels = getUpperMangledLabelNames(labels[0]);
                    for (const label of labels) {
                        let mangledLabel = getMangledLabel(label, upperMangledLabels);
                        mangledLabelNames.set(label, mangledLabel);
                    }
                }
            }
            function getMangledLabel(label, mangledLabels) {
                let mangledLabel = '';
                do {
                    mangledLabel = generator.getName();
                    if (mangledLabel === label.name) {
                        mangledLabel = '';
                    }
                    if (mangledLabels.includes(mangledLabel)) {
                        mangledLabel = '';
                    }
                } while (mangledLabel === '');
                return mangledLabel;
            }
            function getUpperMangledLabelNames(label) {
                const results = [];
                let parent = label.parent;
                while (parent) {
                    let mangledLabelName = mangledLabelNames.get(parent);
                    if (mangledLabelName) {
                        results.push(mangledLabelName);
                    }
                    parent = parent.parent;
                }
                return results;
            }
            /**
             * visit each node to change identifier name to mangled name
             *  - calculate shadow name index to find shadow node
             * @param node
             */
            function visit(node) {
                if (!typescript_1.isIdentifier(node) || !node.parent) {
                    return typescript_1.visitEachChild(node, visit, context);
                }
                if (typescript_1.isLabeledStatement(node.parent) || typescript_1.isBreakOrContinueStatement(node.parent)) {
                    identifierIndex += 1;
                    return updateLabelNode(node);
                }
                const shadowNode = shadowIdentifiers[identifierIndex];
                identifierIndex += 1;
                return updateNameNode(node, shadowNode);
            }
            function findNoSymbolIdentifiers(scope) {
                const noSymbolVisit = (targetNode) => {
                    if (!typescript_1.isIdentifier(targetNode)) {
                        typescript_1.forEachChild(targetNode, noSymbolVisit);
                        return;
                    }
                    // skip property in property access expression
                    if (NodeUtils_1.NodeUtils.isPropertyAccessNode(targetNode)) {
                        return;
                    }
                    const sym = checker.getSymbolAtLocation(targetNode);
                    if (!sym) {
                        scope.mangledNames.add(targetNode.escapedText.toString());
                    }
                };
                noSymbolVisit(scope.block);
            }
            function updateNameNode(node, shadowNode) {
                // skip property in property access expression
                if (NodeUtils_1.NodeUtils.isPropertyAccessNode(node)) {
                    return node;
                }
                const sym = checker.getSymbolAtLocation(shadowNode);
                if (!sym || sym.name === 'default') {
                    return node;
                }
                const mangledName = mangledSymbolNames.get(sym);
                if (!mangledName || mangledName === sym.name) {
                    return node;
                }
                return typescript_1.factory.createIdentifier(mangledName);
            }
            function updateLabelNode(node) {
                let label;
                let labelName = '';
                mangledLabelNames.forEach((value, key) => {
                    if (key.refs.includes(node)) {
                        label = key;
                        labelName = value;
                    }
                });
                return label ? typescript_1.factory.createIdentifier(labelName) : node;
            }
        }
    };
    function isSkippedGlobal(enableTopLevel, scope) {
        return !enableTopLevel && ScopeAnalyzer_1.isGlobalScope(scope);
    }
    const TRANSFORMER_ORDER = 9;
    secharmony.transformerPlugin = {
        'name': 'renameIdentifierPlugin',
        'order': (1 << TRANSFORMER_ORDER),
        'createTransformerFactory': createRenameIdentifierFactory
    };
    secharmony.nameCache = undefined;
    secharmony.historyNameCache = undefined;
})(secharmony || (secharmony = {}));
module.exports = secharmony;
//# sourceMappingURL=RenameIdentifierTransformer.js.map