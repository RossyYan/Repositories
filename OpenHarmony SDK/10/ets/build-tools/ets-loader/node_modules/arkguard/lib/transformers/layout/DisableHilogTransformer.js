"use strict";
/*
 * Copyright (c) 2023 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const typescript_1 = require("typescript");
const TransformUtil_1 = require("../../utils/TransformUtil");
const OhsUtil_1 = require("../../utils/OhsUtil");
var secharmony;
(function (secharmony) {
    const TRANSFORMER_ORDER = 2;
    secharmony.transformerPlugin = {
        'name': 'disableHilogPlugin',
        'order': (1 << TRANSFORMER_ORDER),
        'createTransformerFactory': createDisableHilogFactory
    };
    function createDisableHilogFactory(option) {
        if (!option.mDisableHilog) {
            return null;
        }
        return disableHilogFactory;
        function disableHilogFactory(context) {
            let sourceFile;
            return transformer;
            function transformer(node) {
                if (!typescript_1.isSourceFile(node) || node.fileName.endsWith('.d.ts')) {
                    return node;
                }
                sourceFile = node;
                let resultAst = visitAst(node);
                return typescript_1.setParentRecursive(resultAst, true);
            }
            function visitAst(node) {
                if (typescript_1.isSourceFile(node)) {
                    const visitedAst = typescript_1.visitEachChild(node, visitAst, context);
                    const deletedStatements = deleteHilogStatement(visitedAst.statements);
                    return typescript_1.factory.updateSourceFile(node, deletedStatements);
                }
                if (!typescript_1.isBlock(node)) {
                    return typescript_1.visitEachChild(node, visitAst, context);
                }
                const visitedBlock = typescript_1.visitEachChild(node, visitAst, context);
                const newStatements = deleteHilogStatement(visitedBlock.statements);
                return typescript_1.factory.createBlock(newStatements, true);
            }
            function deleteHilogStatement(statements) {
                const reservedStatements = [];
                statements.forEach((child) => {
                    if (isSimpleHilogStatement(child)) {
                        return;
                    }
                    if (isHilogImportStatement(child)) {
                        if (TransformUtil_1.isCommentedNode(child, sourceFile)) {
                            reservedStatements.push(child);
                        }
                        return;
                    }
                    reservedStatements.push(child);
                });
                return reservedStatements;
            }
            function isHilogImportStatement(node) {
                const ohPackType = OhsUtil_1.findOhImportStatement(node, '@ohos.hilog');
                return ohPackType !== TransformUtil_1.OhPackType.NONE;
            }
            function isSimpleHilogStatement(node) {
                if (!typescript_1.isExpressionStatement(node)) {
                    return false;
                }
                if (!node.expression || !typescript_1.isCallExpression(node.expression)) {
                    return false;
                }
                const expressionCalled = node.expression.expression;
                if (!expressionCalled) {
                    return false;
                }
                if (typescript_1.isPropertyAccessExpression(expressionCalled) && expressionCalled.expression) {
                    if (typescript_1.isIdentifier(expressionCalled.expression) && expressionCalled.expression.text === 'hilog') {
                        return true;
                    }
                }
                if (typescript_1.isElementAccessExpression(expressionCalled) && expressionCalled.expression) {
                    if (typescript_1.isIdentifier(expressionCalled.expression) && expressionCalled.expression.text === 'hilog') {
                        return true;
                    }
                }
                return false;
            }
        }
    }
    secharmony.createDisableHilogFactory = createDisableHilogFactory;
})(secharmony || (secharmony = {}));
module.exports = secharmony;
//# sourceMappingURL=DisableHilogTransformer.js.map