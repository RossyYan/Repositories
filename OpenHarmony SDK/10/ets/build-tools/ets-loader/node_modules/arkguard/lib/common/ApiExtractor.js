"use strict";
/*
 * Copyright (c) 2023 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiExtractor = void 0;
const typescript_1 = require("typescript");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const OhsUtil_1 = require("../utils/OhsUtil");
const ApiReader_1 = require("./ApiReader");
const OhsUtil_2 = require("../utils/OhsUtil");
var ApiExtractor;
(function (ApiExtractor) {
    let ApiType;
    (function (ApiType) {
        ApiType[ApiType["API"] = 1] = "API";
        ApiType[ApiType["COMPONENT"] = 2] = "COMPONENT";
        ApiType[ApiType["PROJECT_DEPENDS"] = 3] = "PROJECT_DEPENDS";
        ApiType[ApiType["PROJECT"] = 4] = "PROJECT";
    })(ApiType = ApiExtractor.ApiType || (ApiExtractor.ApiType = {}));
    let mCurrentExportNameSet = new Set();
    ApiExtractor.mPropertySet = new Set();
    /**
     * filter classes or interfaces with export, default, etc
     */
    const getKeyword = function (modifiers) {
        if (modifiers === undefined) {
            return { hasExport: false, hasDeclare: false };
        }
        let hasExport = false;
        let hasDeclare = false;
        for (const modifier of modifiers) {
            if (modifier.kind === typescript_1.SyntaxKind.ExportKeyword) {
                hasExport = true;
            }
            if (modifier.kind === typescript_1.SyntaxKind.DeclareKeyword) {
                hasDeclare = true;
            }
        }
        return { hasExport: hasExport, hasDeclare: hasDeclare };
    };
    /**
     * get export name list
     * @param astNode
     */
    const visitExport = function (astNode) {
        if (typescript_1.isExportAssignment(astNode)) {
            if (!mCurrentExportNameSet.has(astNode.expression.getText())) {
                mCurrentExportNameSet.add(astNode.expression.getText());
                ApiExtractor.mPropertySet.add(astNode.expression.getText());
            }
            return;
        }
        let { hasExport, hasDeclare } = getKeyword(astNode.modifiers);
        if (!hasExport) {
            addCommonJsExports(astNode);
            return;
        }
        if (astNode.name) {
            if (!mCurrentExportNameSet.has(astNode.name.getText())) {
                mCurrentExportNameSet.add(astNode.name.getText());
                ApiExtractor.mPropertySet.add(astNode.name.getText());
            }
            return;
        }
        if (hasDeclare && astNode.declarationList) {
            astNode.declarationList.declarations.forEach((declaration) => {
                const declarationName = declaration.name.getText();
                if (!mCurrentExportNameSet.has(declarationName)) {
                    mCurrentExportNameSet.add(declarationName);
                    ApiExtractor.mPropertySet.add(declarationName);
                }
            });
        }
    };
    const checkPropertyNeedVisit = function (astNode) {
        if (astNode.name && !mCurrentExportNameSet.has(astNode.name.getText())) {
            return false;
        }
        if (astNode.name === undefined) {
            let { hasDeclare } = getKeyword(astNode.modifiers);
            if (hasDeclare && astNode.declarationList &&
                !mCurrentExportNameSet.has(astNode.declarationList.declarations[0].name.getText())) {
                return false;
            }
        }
        return true;
    };
    /**
     * used only in oh sdk api extract or api of xxx.d.ts declaration file
     * @param astNode
     */
    const visitChildNode = function (astNode) {
        if (!astNode) {
            return;
        }
        if (astNode.name !== undefined && !ApiExtractor.mPropertySet.has(astNode.name.getText())) {
            if (typescript_1.isStringLiteral(astNode.name)) {
                ApiExtractor.mPropertySet.add(astNode.name.text);
            }
            else {
                ApiExtractor.mPropertySet.add(astNode.name.getText());
            }
        }
        astNode.forEachChild((childNode) => {
            visitChildNode(childNode);
        });
    };
    /**
     * visit ast of a file and collect api list
     * used only in oh sdk api extract
     * @param astNode node of ast
     */
    const visitPropertyAndName = function (astNode) {
        if (!checkPropertyNeedVisit(astNode)) {
            return;
        }
        visitChildNode(astNode);
    };
    /**
     * commonjs exports extract
     * examples:
     * - exports.A = 1;
     * - exports.B = hello; // hello can be variable or class ...
     * - exports.C = {};
     * - exports.D = class {};
     * - exports.E = function () {}
     * - class F {}
     * - exports.F = F;
     * - module.exports = {G: {}}
     * - ...
     */
    const addCommonJsExports = function (astNode) {
        if (!typescript_1.isExpressionStatement(astNode) || !astNode.expression) {
            return;
        }
        const expression = astNode.expression;
        if (!typescript_1.isBinaryExpression(expression)) {
            return;
        }
        const left = expression.left;
        if (!typescript_1.isElementAccessExpression(left) && !typescript_1.isPropertyAccessExpression(left)) {
            return;
        }
        if ((left.expression.getText() !== 'exports' && !isModuleExports(left)) ||
            expression.operatorToken.kind !== typescript_1.SyntaxKind.EqualsToken) {
            return;
        }
        if (typescript_1.isElementAccessExpression(left)) {
            if (typescript_1.isStringLiteral(left.argumentExpression)) {
                ApiExtractor.mPropertySet.add(left.argumentExpression.text);
            }
        }
        if (typescript_1.isPropertyAccessExpression(left)) {
            if (typescript_1.isIdentifier(left.name)) {
                ApiExtractor.mPropertySet.add(left.name.getText());
            }
        }
        if (typescript_1.isIdentifier(expression.right)) {
            mCurrentExportNameSet.add(expression.right.getText());
            return;
        }
        if (typescript_1.isClassDeclaration(expression.right) || typescript_1.isClassExpression(expression.right)) {
            OhsUtil_1.getClassProperties(expression.right, ApiExtractor.mPropertySet);
            return;
        }
        if (typescript_1.isObjectLiteralExpression(expression.right)) {
            OhsUtil_1.getObjectProperties(expression.right, ApiExtractor.mPropertySet);
        }
        return;
    };
    // module.exports = { p1: 1 }
    function isModuleExports(astNode) {
        if (typescript_1.isPropertyAccessExpression(astNode)) {
            if (typescript_1.isIdentifier(astNode.expression) && astNode.expression.escapedText.toString() === 'module' &&
                typescript_1.isIdentifier(astNode.name) && astNode.name.escapedText.toString() === 'exports') {
                return true;
            }
        }
        return false;
    }
    /**
     * extract project export name
     * - export {xxx, xxx};
     * - export {xxx as xx, xxx as xx};
     * - export default function/class/...{};
     * - export class xxx{}
     * - ...
     * @param astNode
     */
    const visitProjectExport = function (astNode) {
        if (typescript_1.isExportAssignment(astNode)) {
            // let xxx; export default xxx = a;
            if (typescript_1.isBinaryExpression(astNode.expression)) {
                if (typescript_1.isObjectLiteralExpression(astNode.expression.right)) {
                    OhsUtil_1.getObjectProperties(astNode.expression.right, ApiExtractor.mPropertySet);
                    return;
                }
                if (typescript_1.isClassExpression(astNode.expression.right)) {
                    OhsUtil_1.getClassProperties(astNode.expression.right, ApiExtractor.mPropertySet);
                }
                return;
            }
            // export = xxx; The xxx here can't be obfuscated
            // export default yyy; The yyy here can be obfuscated
            if (typescript_1.isIdentifier(astNode.expression)) {
                if (!mCurrentExportNameSet.has(astNode.expression.getText())) {
                    mCurrentExportNameSet.add(astNode.expression.getText());
                    ApiExtractor.mPropertySet.add(astNode.expression.getText());
                }
                return;
            }
            if (typescript_1.isObjectLiteralExpression(astNode.expression)) {
                OhsUtil_1.getObjectProperties(astNode.expression, ApiExtractor.mPropertySet);
            }
            return;
        }
        if (typescript_1.isExportDeclaration(astNode)) {
            if (astNode.exportClause) {
                if (astNode.exportClause.kind === typescript_1.SyntaxKind.NamedExports) {
                    astNode.exportClause.forEachChild((child) => {
                        if (!typescript_1.isExportSpecifier(child)) {
                            return;
                        }
                        if (child.propertyName) {
                            mCurrentExportNameSet.add(child.propertyName.getText());
                        }
                        let exportName = child.name.getText();
                        ApiExtractor.mPropertySet.add(exportName);
                        mCurrentExportNameSet.add(exportName);
                    });
                }
                if (astNode.exportClause.kind === typescript_1.SyntaxKind.NamespaceExport) {
                    ApiExtractor.mPropertySet.add(astNode.exportClause.name.getText());
                    return;
                }
            }
            return;
        }
        let { hasExport } = getKeyword(astNode.modifiers);
        if (!hasExport) {
            addCommonJsExports(astNode);
            typescript_1.forEachChild(astNode, visitProjectExport);
            return;
        }
        if (astNode.name) {
            if (!mCurrentExportNameSet.has(astNode.name.getText())) {
                mCurrentExportNameSet.add(astNode.name.getText());
                ApiExtractor.mPropertySet.add(astNode.name.getText());
            }
            typescript_1.forEachChild(astNode, visitProjectExport);
            return;
        }
        if (typescript_1.isClassDeclaration(astNode)) {
            OhsUtil_1.getClassProperties(astNode, ApiExtractor.mPropertySet);
            return;
        }
        if (typescript_1.isVariableStatement(astNode)) {
            astNode.declarationList.forEachChild((child) => {
                if (typescript_1.isVariableDeclaration(child) && !mCurrentExportNameSet.has(child.name.getText())) {
                    mCurrentExportNameSet.add(child.name.getText());
                    ApiExtractor.mPropertySet.add(child.name.getText());
                }
            });
            return;
        }
        typescript_1.forEachChild(astNode, visitProjectExport);
    };
    /**
     * extract the class, enum, and object properties of the export in the project before obfuscation
     * class A{};
     * export = A; need to be considered
     * export = namespace;
     * This statement also needs to determine whether there is an export in the namespace, and namespaces are also allowed in the namespace
     * @param astNode
     */
    const visitProjectNode = function (astNode) {
        var _a, _b;
        const currentPropsSet = new Set();
        let nodeName = (_a = astNode.name) === null || _a === void 0 ? void 0 : _a.text;
        if ((typescript_1.isClassDeclaration(astNode) || typescript_1.isStructDeclaration(astNode))) {
            OhsUtil_1.getClassProperties(astNode, currentPropsSet);
        }
        else if (typescript_1.isEnumDeclaration(astNode)) { // collect export enum structure properties
            OhsUtil_1.getEnumProperties(astNode, currentPropsSet);
        }
        else if (typescript_1.isVariableDeclaration(astNode)) {
            if (astNode.initializer) {
                if (typescript_1.isObjectLiteralExpression(astNode.initializer)) {
                    OhsUtil_1.getObjectProperties(astNode.initializer, currentPropsSet);
                }
                else if (typescript_1.isClassExpression(astNode.initializer)) {
                    OhsUtil_1.getClassProperties(astNode.initializer, currentPropsSet);
                }
            }
            nodeName = (_b = astNode.name) === null || _b === void 0 ? void 0 : _b.getText();
        }
        else if (typescript_1.isInterfaceDeclaration(astNode)) {
            OhsUtil_1.getInterfaceProperties(astNode, currentPropsSet);
        }
        else if (typescript_1.isTypeAliasDeclaration(astNode)) {
            OhsUtil_1.getTypeAliasProperties(astNode, currentPropsSet);
        }
        else if (typescript_1.isElementAccessExpression(astNode)) {
            OhsUtil_1.getElementAccessExpressionProperties(astNode, currentPropsSet);
        }
        else if (typescript_1.isObjectLiteralExpression(astNode)) {
            OhsUtil_1.getObjectProperties(astNode, currentPropsSet);
        }
        else if (typescript_1.isClassExpression(astNode)) {
            OhsUtil_1.getClassProperties(astNode, currentPropsSet);
        }
        if (nodeName && mCurrentExportNameSet.has(nodeName)) {
            addElement(currentPropsSet);
        }
        typescript_1.forEachChild(astNode, visitProjectNode);
    };
    function addElement(currentPropsSet) {
        currentPropsSet.forEach((element) => {
            ApiExtractor.mPropertySet.add(element);
        });
        currentPropsSet.clear();
    }
    /**
     * parse file to api list and save to json object
     * @param fileName file name of api file
     * @param apiType
     * @private
     */
    const parseFile = function (fileName, apiType) {
        const sourceFile = typescript_1.createSourceFile(fileName, fs_1.default.readFileSync(fileName).toString(), typescript_1.ScriptTarget.ES2015, true);
        // get export name list
        switch (apiType) {
            case ApiType.COMPONENT:
                typescript_1.forEachChild(sourceFile, visitChildNode);
                break;
            case ApiType.API:
                mCurrentExportNameSet.clear();
                typescript_1.forEachChild(sourceFile, visitExport);
                typescript_1.forEachChild(sourceFile, visitPropertyAndName);
                mCurrentExportNameSet.clear();
                break;
            case ApiType.PROJECT_DEPENDS:
            case ApiType.PROJECT:
                if (fileName.endsWith('.d.ts') || fileName.endsWith('.d.ets')) {
                    typescript_1.forEachChild(sourceFile, visitChildNode);
                    break;
                }
                mCurrentExportNameSet.clear();
                typescript_1.forEachChild(sourceFile, visitProjectExport);
                typescript_1.forEachChild(sourceFile, visitProjectNode);
                if (ApiReader_1.scanProjectConfig.mKeepStringProperty) {
                    OhsUtil_2.stringPropsSet.forEach((element) => {
                        ApiExtractor.mPropertySet.add(element);
                    });
                    OhsUtil_2.stringPropsSet.clear();
                }
                mCurrentExportNameSet.clear();
                break;
            default:
                break;
        }
    };
    const projectExtensions = ['.ets', '.ts', '.js'];
    const projectDependencyExtensions = ['.d.ets', '.d.ts', '.ets', '.ts', '.js'];
    /**
     * traverse files of  api directory
     * @param apiPath api directory path
     * @param apiType
     * @private
     */
    ApiExtractor.traverseApiFiles = function (apiPath, apiType) {
        let fileNames = [];
        if (fs_1.default.statSync(apiPath).isDirectory()) {
            fileNames = fs_1.default.readdirSync(apiPath);
            for (let fileName of fileNames) {
                let filePath = path_1.default.join(apiPath, fileName);
                if (fs_1.default.statSync(filePath).isDirectory()) {
                    ApiExtractor.traverseApiFiles(filePath, apiType);
                    continue;
                }
                const suffix = path_1.default.extname(filePath);
                if ((apiType !== ApiType.PROJECT) && !projectDependencyExtensions.includes(suffix)) {
                    continue;
                }
                if (apiType === ApiType.PROJECT && !projectExtensions.includes(suffix)) {
                    continue;
                }
                parseFile(filePath, apiType);
            }
        }
        else {
            parseFile(apiPath, apiType);
        }
    };
    /**
     * desc: parse openHarmony sdk to get api list
     * @param version version of api, e.g. version 5.0.1.0 for api 9
     * @param sdkPath sdk real path of openHarmony
     * @param isEts true for ets, false for js
     * @param outputDir: sdk api output directory
     */
    function parseOhSdk(sdkPath, version, isEts, outputDir) {
        ApiExtractor.mPropertySet.clear();
        // visit api directory
        const apiPath = path_1.default.join(sdkPath, (isEts ? 'ets' : 'js'), version, 'api');
        ApiExtractor.traverseApiFiles(apiPath, ApiType.API);
        // visit component directory if ets
        if (isEts) {
            const componentPath = path_1.default.join(sdkPath, 'ets', version, 'component');
            ApiExtractor.traverseApiFiles(componentPath, ApiType.COMPONENT);
        }
        // visit the UI conversion API
        const uiConversionPath = path_1.default.join(sdkPath, (isEts ? 'ets' : 'js'), version, 'build-tools', 'ets-loader', 'lib', 'pre_define.js');
        extractStringsFromFile(uiConversionPath);
        const reservedProperties = [...ApiExtractor.mPropertySet.values()];
        ApiExtractor.mPropertySet.clear();
        writeToFile(reservedProperties, path_1.default.join(outputDir, 'propertiesReserved.json'));
    }
    ApiExtractor.parseOhSdk = parseOhSdk;
    function extractStringsFromFile(filePath) {
        let collections = [];
        const fileContent = fs_1.default.readFileSync(filePath, 'utf-8');
        const regex = /"([^"]*)"/g;
        const matches = fileContent.match(regex);
        if (matches) {
            collections = matches.map(match => match.slice(1, -1));
        }
        collections.forEach(name => ApiExtractor.mPropertySet.add(name));
    }
    ApiExtractor.extractStringsFromFile = extractStringsFromFile;
    /**
     * parse common project or file to extract exported api list
     * @return reserved api names
     */
    function parseCommonProject(projectPath) {
        ApiExtractor.mPropertySet.clear();
        if (fs_1.default.lstatSync(projectPath).isFile()) {
            if (projectPath.endsWith('.ets') || projectPath.endsWith('.ts') || projectPath.endsWith('.js')) {
                parseFile(projectPath, ApiType.PROJECT);
            }
        }
        else {
            ApiExtractor.traverseApiFiles(projectPath, ApiType.PROJECT);
        }
        const reservedProperties = [...ApiExtractor.mPropertySet];
        ApiExtractor.mPropertySet.clear();
        return reservedProperties;
    }
    ApiExtractor.parseCommonProject = parseCommonProject;
    /**
     * parse api of third party libs like libs in node_modules
     * @param libPath
     */
    function parseThirdPartyLibs(libPath) {
        ApiExtractor.mPropertySet.clear();
        if (fs_1.default.lstatSync(libPath).isFile()) {
            if (libPath.endsWith('.ets') || libPath.endsWith('.ts') || libPath.endsWith('.js')) {
                parseFile(libPath, ApiType.PROJECT_DEPENDS);
            }
        }
        else {
            const filesAndfolders = fs_1.default.readdirSync(libPath);
            for (let subPath of filesAndfolders) {
                ApiExtractor.traverseApiFiles(path_1.default.join(libPath, subPath), ApiType.PROJECT_DEPENDS);
            }
        }
        const reservedProperties = [...ApiExtractor.mPropertySet];
        ApiExtractor.mPropertySet.clear();
        return reservedProperties;
    }
    ApiExtractor.parseThirdPartyLibs = parseThirdPartyLibs;
    /**
     * save api json object to file
     * @private
     */
    function writeToFile(reservedProperties, outputPath) {
        let str = JSON.stringify(reservedProperties, null, '\t');
        fs_1.default.writeFileSync(outputPath, str);
    }
    ApiExtractor.writeToFile = writeToFile;
})(ApiExtractor = exports.ApiExtractor || (exports.ApiExtractor = {}));
//# sourceMappingURL=ApiExtractor.js.map