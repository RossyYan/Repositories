"use strict";
/*
 * Copyright (c) 2023 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReservedNameGenerator = void 0;
/**
 * need reserved keyword which contain transformDict character
 */
const gReservedIdentifier = [
    'let', 'return', 'break', 'continue', 'const', 'var', 'console', 'enum',
    'boolean', 'number', 'string', 'any', 'void', 'undefined', 'null',
    'never', 'function', 'declare', 'as', 'while', 'for', 'if', 'else',
    'true', 'false', 'try', 'catch', 'throw', 'type', 'class', 'new',
    'interface', 'export', 'readonly', 'private', 'public', 'extends',
    'implements', 'constructor', 'this', 'static', 'protected', 'switch',
    'case', 'default', 'typeof', 'instanceof', 'in', 'of', 'import', 'require',
    'module', 'from', 'abstract', 'async', 'namespace', 'arguments', '__global'
];
const gTransformDict = {
    'a': 'α',
    'b': 'þ',
    'c': 'ç',
    'e': 'è',
    'i': 'ì',
    'k': 'κ',
    'l': 'ι',
    'n': 'η',
    'o': 'ο',
    'p': 'ρ',
    'u': 'υ',
    'v': 'ν',
    'w': 'ω',
    'x': 'χ',
    'y': 'γ',
    'z': 'ζ'
};
/**
 * @Desc: a name generator which use reserved keywords similar words to get obfuscated name
 */
class ReservedNameGenerator {
    constructor(options) {
        this.mTransformSet = new Set();
        this.mReservedNames = options === null || options === void 0 ? void 0 : options.reservedNames;
        const dictKeys = Object.keys(gTransformDict);
        for (const key of dictKeys) {
            this.mTransformSet.add(key);
        }
        this.mIdIndex = 0;
        this.mWordIndex = 1;
        this.mWordInfo = [];
        this.getWordInfo(gReservedIdentifier[this.mIdIndex]);
    }
    getWordInfo(originName) {
        for (let i = 0; i < originName.length; i++) {
            if (this.mTransformSet.has(originName[i])) {
                this.mWordInfo.push(i);
            }
        }
    }
    transformName(originName) {
        let charArr = originName.split('');
        const BINARY_RADIX = 2;
        let binaryArr = this.mWordIndex.toString(BINARY_RADIX).split('').reverse().join('');
        for (let i = 0; i < binaryArr.length; i++) {
            if (binaryArr[i] === '1') {
                charArr[this.mWordInfo[i]] = gTransformDict[charArr[this.mWordInfo[i]]];
            }
        }
        this.mWordIndex += 1;
        if (this.mWordIndex === Math.pow(BINARY_RADIX, this.mWordInfo.length)) {
            this.mIdIndex += 1;
            this.mWordInfo.length = 0;
            this.mWordIndex = 1;
            if (this.mIdIndex < gReservedIdentifier.length) {
                this.getWordInfo(gReservedIdentifier[this.mIdIndex]);
            }
        }
        return charArr.join('');
    }
    /**
     * @return: null for end
     */
    getName() {
        var _a;
        let originName = gReservedIdentifier[this.mIdIndex];
        let transformedName = this.transformName(originName);
        if (this.mIdIndex >= gReservedIdentifier.length) {
            return null;
        }
        if ((_a = this.mReservedNames) === null || _a === void 0 ? void 0 : _a.has(transformedName)) {
            return this.getName();
        }
        return transformedName;
    }
    reset() {
        this.mIdIndex = 0;
        this.mWordIndex = 1;
        this.mWordInfo.length = 0;
        this.getWordInfo(gReservedIdentifier[this.mIdIndex]);
    }
}
exports.ReservedNameGenerator = ReservedNameGenerator;
//# sourceMappingURL=ReservedNameGenerator.js.map