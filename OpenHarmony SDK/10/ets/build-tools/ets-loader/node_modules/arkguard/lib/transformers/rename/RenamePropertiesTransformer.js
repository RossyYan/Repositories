"use strict";
/*
 * Copyright (c) 2023 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const typescript_1 = require("typescript");
const NameFactory_1 = require("../../generator/NameFactory");
const NodeUtils_1 = require("../../utils/NodeUtils");
const OhsUtil_1 = require("../../utils/OhsUtil");
var secharmony;
(function (secharmony) {
    /**
     * global mangled properties table used by all files in a project
     */
    secharmony.globalMangledTable = undefined;
    // used for property cache
    secharmony.historyMangledTable = undefined;
    /**
     * Rename Properties Transformer
     *
     * @param option obfuscation options
     */
    const createRenamePropertiesFactory = function (option) {
        let profile = option === null || option === void 0 ? void 0 : option.mNameObfuscation;
        if (!profile || !profile.mEnable || !profile.mRenameProperties) {
            return null;
        }
        return renamePropertiesFactory;
        function renamePropertiesFactory(context) {
            var _a;
            let options = {};
            if (profile.mNameGeneratorType === NameFactory_1.NameGeneratorType.HEX) {
                options.hexWithPrefixSuffix = true;
            }
            let generator = NameFactory_1.getNameGenerator(profile.mNameGeneratorType, options);
            let tmpReservedProps = (_a = profile === null || profile === void 0 ? void 0 : profile.mReservedProperties) !== null && _a !== void 0 ? _a : [];
            let reservedProperties = new Set(tmpReservedProps);
            let currentConstructorParams = new Set();
            return renamePropertiesTransformer;
            function renamePropertiesTransformer(node) {
                collectReservedNames(node);
                if (secharmony.globalMangledTable === undefined) {
                    secharmony.globalMangledTable = new Map();
                }
                let ret = renameProperties(node);
                return typescript_1.setParentRecursive(ret, true);
            }
            function renameProperties(node) {
                if (typescript_1.isConstructorDeclaration(node)) {
                    currentConstructorParams.clear();
                }
                if (NodeUtils_1.NodeUtils.isClassPropertyInConstructorParams(node)) {
                    currentConstructorParams.add(node.escapedText.toString());
                    return renameProperty(node, false);
                }
                if (NodeUtils_1.NodeUtils.isClassPropertyInConstructorBody(node, currentConstructorParams)) {
                    if (currentConstructorParams.has(node.escapedText.toString())) {
                        return renameProperty(node, false);
                    }
                }
                if (!NodeUtils_1.NodeUtils.isPropertyNode(node)) {
                    return typescript_1.visitEachChild(node, renameProperties, context);
                }
                if (typescript_1.isElementAccessExpression(node.parent)) {
                    return renameElementAccessProperty(node);
                }
                if (typescript_1.isComputedPropertyName(node)) {
                    return renameComputedProperty(node);
                }
                return renameProperty(node, false);
            }
            function renameElementAccessProperty(node) {
                if (typescript_1.isStringLiteralLike(node)) {
                    return renameProperty(node, false);
                }
                return typescript_1.visitEachChild(node, renameProperties, context);
            }
            function renameComputedProperty(node) {
                if (typescript_1.isStringLiteralLike(node.expression) || typescript_1.isNumericLiteral(node.expression)) {
                    let prop = renameProperty(node.expression, true);
                    if (prop !== node.expression) {
                        return typescript_1.factory.createComputedPropertyName(prop);
                    }
                }
                if (typescript_1.isIdentifier(node.expression)) {
                    return node;
                }
                return typescript_1.visitEachChild(node, renameProperties, context);
            }
            function renameProperty(node, computeName) {
                if (!typescript_1.isStringLiteralLike(node) && !typescript_1.isIdentifier(node) && !typescript_1.isPrivateIdentifier(node) && !typescript_1.isNumericLiteral(node)) {
                    return typescript_1.visitEachChild(node, renameProperties, context);
                }
                let original = node.text;
                if (reservedProperties.has(original)) {
                    return node;
                }
                let mangledName = getPropertyName(original);
                if (typescript_1.isStringLiteralLike(node)) {
                    return typescript_1.factory.createStringLiteral(mangledName);
                }
                if (typescript_1.isNumericLiteral(node)) {
                    return computeName ? typescript_1.factory.createStringLiteral(mangledName) : typescript_1.factory.createIdentifier(mangledName);
                }
                if (typescript_1.isIdentifier(node) || typescript_1.isNumericLiteral(node)) {
                    return typescript_1.factory.createIdentifier(mangledName);
                }
                return typescript_1.factory.createPrivateIdentifier('#' + mangledName);
            }
            function getPropertyName(original) {
                if (reservedProperties.has(original)) {
                    return original;
                }
                const historyName = secharmony.historyMangledTable === null || secharmony.historyMangledTable === void 0 ? void 0 : secharmony.historyMangledTable.get(original);
                let mangledName = historyName ? historyName : secharmony.globalMangledTable.get(original);
                while (!mangledName) {
                    mangledName = generator.getName();
                    if (mangledName === original || reservedProperties.has(mangledName)) {
                        mangledName = null;
                        continue;
                    }
                    let reserved = [...secharmony.globalMangledTable.values()];
                    if (secharmony.historyMangledTable) {
                        reserved = [...reserved, ...secharmony.historyMangledTable.values()];
                    }
                    if (reserved.includes(mangledName)) {
                        mangledName = null;
                    }
                }
                secharmony.globalMangledTable.set(original, mangledName);
                return mangledName;
            }
            function visitEnumInitializer(childNode) {
                if (!typescript_1.isIdentifier(childNode)) {
                    typescript_1.forEachChild(childNode, visitEnumInitializer);
                    return;
                }
                if (NodeUtils_1.NodeUtils.isPropertyNode(childNode)) {
                    return;
                }
                if (typescript_1.isTypeNode(childNode)) {
                    return;
                }
                reservedProperties.add(childNode.text);
            }
            // enum syntax has special scenarios
            function collectReservedNames(node) {
                // collect ViewPU class properties
                if (typescript_1.isClassDeclaration(node) && OhsUtil_1.isViewPUBasedClass(node)) {
                    getViewPUClassProperties(node, reservedProperties);
                    return;
                }
                // collect reserved name of enum
                // example: enum H {A, B = A + 1}, enum H = {A, B= 1 + (A + 1)}; A is reserved
                if (typescript_1.isEnumMember(node) && node.initializer) {
                    // collect enum properties
                    node.initializer.forEachChild(visitEnumInitializer);
                    return;
                }
                typescript_1.forEachChild(node, collectReservedNames);
            }
            function getViewPUClassProperties(classNode, propertySet) {
                if (!classNode || !classNode.members) {
                    return;
                }
                classNode.members.forEach((member) => {
                    const memberName = member.name;
                    if (!member || !memberName) {
                        return;
                    }
                    OhsUtil_1.collectPropertyNamesAndStrings(memberName, propertySet);
                });
            }
        }
    };
    const TRANSFORMER_ORDER = 6;
    secharmony.transformerPlugin = {
        'name': 'renamePropertiesPlugin',
        'order': (1 << TRANSFORMER_ORDER),
        'createTransformerFactory': createRenamePropertiesFactory
    };
})(secharmony || (secharmony = {}));
module.exports = secharmony;
//# sourceMappingURL=RenamePropertiesTransformer.js.map