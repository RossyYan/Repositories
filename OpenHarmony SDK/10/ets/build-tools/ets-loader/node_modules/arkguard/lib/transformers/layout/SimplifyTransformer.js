"use strict";
/*
 * Copyright (c) 2023 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const typescript_1 = require("typescript");
const TransformUtil_1 = require("../../utils/TransformUtil");
var secharmony;
(function (secharmony) {
    const TRANSFORMER_ORDER = 5;
    secharmony.transformerPlugin = {
        'name': 'simplifyPlugin',
        'order': (1 << TRANSFORMER_ORDER),
        'createTransformerFactory': createSimplifyFactory
    };
    function createSimplifyFactory(option) {
        if (!option.mSimplify) {
            return null;
        }
        return simplifyFactory;
        function simplifyFactory(context) {
            const MIN_STATEMENTS_LEN = 2;
            let sourceFile;
            return transformer;
            function transformer(node) {
                if (!typescript_1.isSourceFile(node) || node.fileName.endsWith('.d.ts')) {
                    return node;
                }
                sourceFile = node;
                return typescript_1.setParentRecursive(visitStatements(node), true);
            }
            function visitStatements(node) {
                if (!typescript_1.isSourceFile(node) && !typescript_1.isBlock(node)) {
                    return typescript_1.visitEachChild(node, visitStatements, context);
                }
                const simplified = typescript_1.visitEachChild(node, visitStatements, context);
                if (node.statements.length < MIN_STATEMENTS_LEN) {
                    return node;
                }
                return simplifyStatements(simplified);
            }
            /**
             * use variable statement merge and expression merge to simplify code
             * @param node
             */
            function simplifyStatements(node) {
                if (!typescript_1.isSourceFile(node) && !typescript_1.isBlock(node)) {
                    return node;
                }
                let simplifiedStatements = [];
                const continuousStatements = [];
                let nodeFlag = undefined;
                let modifiers = undefined;
                let preType = undefined;
                function mergeArray() {
                    if (continuousStatements.length < MIN_STATEMENTS_LEN) {
                        simplifiedStatements = [...simplifiedStatements, ...continuousStatements];
                        return;
                    }
                    if (preType === typescript_1.SyntaxKind.VariableStatement) {
                        simplifiedStatements.push(mergeVariableStatements(continuousStatements));
                        return;
                    }
                    if (preType === typescript_1.SyntaxKind.ExpressionStatement) {
                        simplifiedStatements.push(mergeExpression(continuousStatements));
                    }
                }
                function doMerge(currentType, child) {
                    if (preType === currentType) {
                        if (preType !== typescript_1.SyntaxKind.VariableStatement) {
                            return;
                        }
                        if (nodeFlag === child.declarationList.flags) {
                            if (!modifiers && !child.modifiers) {
                                return;
                            }
                            let isSame = true;
                            if (modifiers && child.modifiers && modifiers.length === child.modifiers.length) {
                                modifiers.forEach((modifier, index) => {
                                    if (modifier.kind !== child.modifiers[index].kind) {
                                        isSame = false;
                                    }
                                });
                            }
                            else {
                                isSame = false;
                            }
                            if (isSame) {
                                return;
                            }
                        }
                        mergeArray();
                        nodeFlag = child.declarationList.flags;
                        modifiers = child.modifiers;
                        continuousStatements.length = 0;
                        return;
                    }
                    if (preType === typescript_1.SyntaxKind.VariableStatement) {
                        nodeFlag = undefined;
                        modifiers = undefined;
                        mergeArray();
                    }
                    else if (preType === typescript_1.SyntaxKind.ExpressionStatement) {
                        mergeArray();
                    }
                    continuousStatements.length = 0;
                    preType = currentType;
                }
                node.statements.forEach((child) => {
                    if (TransformUtil_1.isCommentedNode(child, sourceFile) ||
                        (typescript_1.isExpressionStatement(child) && typescript_1.isStringLiteral(child.expression)) ||
                        TransformUtil_1.isSuperCallStatement(child)) {
                        doMerge(undefined, undefined);
                        simplifiedStatements.push(child);
                        return;
                    }
                    if (typescript_1.isVariableStatement(child)) {
                        doMerge(typescript_1.SyntaxKind.VariableStatement, child);
                        continuousStatements.push(child);
                        nodeFlag = child.declarationList.flags;
                        modifiers = child.modifiers;
                        return;
                    }
                    if (typescript_1.isExpressionStatement(child)) {
                        doMerge(typescript_1.SyntaxKind.ExpressionStatement, child);
                        continuousStatements.push(child);
                        return;
                    }
                    if (typescript_1.isReturnStatement(child) && child.expression !== undefined) {
                        doMerge(typescript_1.SyntaxKind.ExpressionStatement, child);
                        continuousStatements.push(child);
                        doMerge(undefined, undefined);
                        return;
                    }
                    // do merge on continuous stopped
                    doMerge(undefined, child);
                    simplifiedStatements.push(child);
                });
                doMerge(undefined, undefined);
                if (typescript_1.isSourceFile(node)) {
                    return typescript_1.factory.updateSourceFile(node, simplifiedStatements);
                }
                return typescript_1.factory.createBlock(simplifiedStatements, true);
            }
            /**
             * merge variable statement, need same type and same modifier variable and continuous
             * @param variableStatements
             */
            function mergeVariableStatements(variableStatements) {
                let variableDeclarations = [];
                variableStatements.forEach((statement) => {
                    variableDeclarations = [...variableDeclarations, ...statement.declarationList.declarations];
                });
                return typescript_1.factory.createVariableStatement(variableStatements[0].modifiers, typescript_1.factory.createVariableDeclarationList(variableDeclarations, variableStatements[0].declarationList.flags));
            }
            /**
             * merge expression, include:
             *   - continuous expression like a=a+1; b=b+1;
             */
            function mergeExpression(expressionStatements) {
                let pos = 1;
                let expression = expressionStatements[0].expression;
                const statementsLength = expressionStatements.length;
                while (pos < statementsLength) {
                    expression = typescript_1.factory.createBinaryExpression(expression, typescript_1.SyntaxKind.CommaToken, expressionStatements[pos].expression);
                    pos += 1;
                }
                if (typescript_1.isReturnStatement(expressionStatements[statementsLength - 1])) {
                    return typescript_1.factory.createReturnStatement(expression);
                }
                return typescript_1.factory.createExpressionStatement(expression);
            }
        }
    }
    secharmony.createSimplifyFactory = createSimplifyFactory;
})(secharmony || (secharmony = {}));
module.exports = secharmony;
//# sourceMappingURL=SimplifyTransformer.js.map