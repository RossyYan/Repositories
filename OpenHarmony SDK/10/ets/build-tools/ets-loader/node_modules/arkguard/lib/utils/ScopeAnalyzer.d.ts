import type { Identifier, LabeledStatement, Node, SourceFile, Symbol, TypeChecker } from 'typescript';
/**
 * kind of a scope
 */
declare namespace secharmony {
    /**
     * type of scope
     */
    enum ScopeKind {
        GLOBAL = 0,
        MODULE = 1,
        FUNCTION = 2,
        CLASS = 3,
        FOR = 4,
        SWITCH = 5,
        BLOCK = 6,
        INTERFACE = 7,
        CATCH = 8,
        ENUM = 9,
        OBJECT_LITERAL = 10
    }
    function isGlobalScope(scope: Scope): boolean;
    function isFunctionScope(scope: Scope): boolean;
    function isClassScope(scope: Scope): boolean;
    function isInterfaceScope(scope: Scope): boolean;
    function isEnumScope(scope: Scope): boolean;
    function isObjectLiteralScope(scope: Scope): boolean;
    /**
     * Structure of a scope
     */
    interface Scope {
        /**
         * name of a scope
         */
        name: string;
        /**
         * kind of current scope
         */
        kind: ScopeKind;
        /**
         * node of current scope in ast
         */
        block: Node;
        /**
         * parent scope of current scope
         */
        parent: Scope | undefined;
        /**
         * sub scopes of current scope,
         */
        children: Scope[];
        /**
         * symbols define in current scope
         */
        defs: Set<Symbol>;
        /**
         * labels in current scope
         */
        labels: Label[];
        /**
         * location path description of current scope,
         */
        loc: string;
        importNames?: Set<string>;
        exportNames?: Set<string>;
        mangledNames?: Set<string>;
        /**
         * add a sub scope to current scope
         *
         * @param child
         */
        addChild(child: Scope): void;
        /**
         * add definition symbol into current scope
         *
         * @param def definition symbol
         */
        addDefinition(def: Symbol): void;
        /**
         * add label to current scope
         *
         * @param label label statement
         */
        addLabel(label: Label): void;
        /**
         * get symbol location
         *
         * @param sym symbol
         */
        getSymbolLocation(sym: Symbol): string;
        /**
         * get label location
         *
         * @param label
         */
        getLabelLocation(label: Label): string;
    }
    function createScope(name: string, node: Node, type: ScopeKind, lexicalScope?: boolean, upper?: Scope): Scope;
    interface Label {
        name: string;
        locInfo: string;
        refs: Identifier[];
        parent: Label | undefined;
        children: Label[];
        scope: Scope;
    }
    function createLabel(node: LabeledStatement, scope: Scope, parent?: Label | undefined): Label;
    interface ScopeManager {
        /**
         * get reserved names like ViewPU component class name
         */
        getReservedNames(): Set<string>;
        /**
         * do scope analysis
         *
         * @param ast ast tree of a source file
         * @param checker
         */
        analyze(ast: SourceFile, checker: TypeChecker): void;
        /**
         * get root scope of a file
         */
        getRootScope(): Scope;
        /**
         * find block Scope of a node
         * @param node
         */
        getScopeOfNode(node: Node): Scope | undefined;
    }
    function createScopeManager(): ScopeManager;
}
export = secharmony;
